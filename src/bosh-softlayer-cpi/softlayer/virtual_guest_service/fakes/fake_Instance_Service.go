// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-softlayer-cpi/registry"
	instance "bosh-softlayer-cpi/softlayer/virtual_guest_service"
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
)

type FakeService struct {
	AttachDiskStub        func(id int, diskID int) ([]byte, error)
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		id     int
		diskID int
	}
	attachDiskReturns struct {
		result1 []byte
		result2 error
	}
	attachDiskReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	AttachedDisksStub        func(id int) ([]string, error)
	attachedDisksMutex       sync.RWMutex
	attachedDisksArgsForCall []struct {
		id int
	}
	attachedDisksReturns struct {
		result1 []string
		result2 error
	}
	attachedDisksReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	AttachEphemeralDiskStub        func(id int, diskSize int) error
	attachEphemeralDiskMutex       sync.RWMutex
	attachEphemeralDiskArgsForCall []struct {
		id       int
		diskSize int
	}
	attachEphemeralDiskReturns struct {
		result1 error
	}
	attachEphemeralDiskReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStub        func(virtualGuest *datatypes.Virtual_Guest, enableVps bool, stemcellID int, sshKeys []int, userData *registry.SoftlayerUserData) (int, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		virtualGuest *datatypes.Virtual_Guest
		enableVps    bool
		stemcellID   int
		sshKeys      []int
		userData     *registry.SoftlayerUserData
	}
	createReturns struct {
		result1 int
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	UpgradeInstanceStub        func(id int, cpu int, memory int, network int, privateCPU bool, dedicatedHost bool) error
	upgradeInstanceMutex       sync.RWMutex
	upgradeInstanceArgsForCall []struct {
		id            int
		cpu           int
		memory        int
		network       int
		privateCPU    bool
		dedicatedHost bool
	}
	upgradeInstanceReturns struct {
		result1 error
	}
	upgradeInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureNetworksStub        func(id int, networks instance.Networks) (instance.Networks, error)
	configureNetworksMutex       sync.RWMutex
	configureNetworksArgsForCall []struct {
		id       int
		networks instance.Networks
	}
	configureNetworksReturns struct {
		result1 instance.Networks
		result2 error
	}
	configureNetworksReturnsOnCall map[int]struct {
		result1 instance.Networks
		result2 error
	}
	CleanUpStub        func(id int) error
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		id int
	}
	cleanUpReturns struct {
		result1 error
	}
	cleanUpReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSshKeyStub        func(label string, key string, fingerPrint string) (int, error)
	createSshKeyMutex       sync.RWMutex
	createSshKeyArgsForCall []struct {
		label       string
		key         string
		fingerPrint string
	}
	createSshKeyReturns struct {
		result1 int
		result2 error
	}
	createSshKeyReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DeleteStub        func(id int, enableVps bool) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		id        int
		enableVps bool
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DetachDiskStub        func(id int, diskID int) error
	detachDiskMutex       sync.RWMutex
	detachDiskArgsForCall []struct {
		id     int
		diskID int
	}
	detachDiskReturns struct {
		result1 error
	}
	detachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSshKeyStub        func(id int) error
	deleteSshKeyMutex       sync.RWMutex
	deleteSshKeyArgsForCall []struct {
		id int
	}
	deleteSshKeyReturns struct {
		result1 error
	}
	deleteSshKeyReturnsOnCall map[int]struct {
		result1 error
	}
	EditStub        func(id int, instance *datatypes.Virtual_Guest) error
	editMutex       sync.RWMutex
	editArgsForCall []struct {
		id       int
		instance *datatypes.Virtual_Guest
	}
	editReturns struct {
		result1 error
	}
	editReturnsOnCall map[int]struct {
		result1 error
	}
	FindStub        func(id int) (*datatypes.Virtual_Guest, error)
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		id int
	}
	findReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	findReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	FindByPrimaryBackendIpStub        func(ip string) (*datatypes.Virtual_Guest, error)
	findByPrimaryBackendIpMutex       sync.RWMutex
	findByPrimaryBackendIpArgsForCall []struct {
		ip string
	}
	findByPrimaryBackendIpReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	findByPrimaryBackendIpReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	FindByPrimaryIpStub        func(ip string) (*datatypes.Virtual_Guest, error)
	findByPrimaryIpMutex       sync.RWMutex
	findByPrimaryIpArgsForCall []struct {
		ip string
	}
	findByPrimaryIpReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	findByPrimaryIpReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	GetVlanStub        func(id int, mask string) (*datatypes.Network_Vlan, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		id   int
		mask string
	}
	getVlanReturns struct {
		result1 *datatypes.Network_Vlan
		result2 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Vlan
		result2 error
	}
	GetSubnetStub        func(id int, mask string) (*datatypes.Network_Subnet, error)
	getSubnetMutex       sync.RWMutex
	getSubnetArgsForCall []struct {
		id   int
		mask string
	}
	getSubnetReturns struct {
		result1 *datatypes.Network_Subnet
		result2 error
	}
	getSubnetReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Subnet
		result2 error
	}
	RebootStub        func(id int) error
	rebootMutex       sync.RWMutex
	rebootArgsForCall []struct {
		id int
	}
	rebootReturns struct {
		result1 error
	}
	rebootReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadOSStub        func(id int, stemcellID int, sshKeyIds []int, hostname string, domain string, userData *registry.SoftlayerUserData) error
	reloadOSMutex       sync.RWMutex
	reloadOSArgsForCall []struct {
		id         int
		stemcellID int
		sshKeyIds  []int
		hostname   string
		domain     string
		userData   *registry.SoftlayerUserData
	}
	reloadOSReturns struct {
		result1 error
	}
	reloadOSReturnsOnCall map[int]struct {
		result1 error
	}
	SetMetadataStub        func(id int, vmMetadata instance.Metadata) error
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		id         int
		vmMetadata instance.Metadata
	}
	setMetadataReturns struct {
		result1 error
	}
	setMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateInstanceUserDataStub        func(id int, userData *string) error
	updateInstanceUserDataMutex       sync.RWMutex
	updateInstanceUserDataArgsForCall []struct {
		id       int
		userData *string
	}
	updateInstanceUserDataReturns struct {
		result1 error
	}
	updateInstanceUserDataReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeService) AttachDisk(id int, diskID int) ([]byte, error) {
	fake.attachDiskMutex.Lock()
	ret, specificReturn := fake.attachDiskReturnsOnCall[len(fake.attachDiskArgsForCall)]
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		id     int
		diskID int
	}{id, diskID})
	fake.recordInvocation("AttachDisk", []interface{}{id, diskID})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(id, diskID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachDiskReturns.result1, fake.attachDiskReturns.result2
}

func (fake *FakeService) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeService) AttachDiskArgsForCall(i int) (int, int) {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].id, fake.attachDiskArgsForCall[i].diskID
}

func (fake *FakeService) AttachDiskReturns(result1 []byte, result2 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachDiskReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.AttachDiskStub = nil
	if fake.attachDiskReturnsOnCall == nil {
		fake.attachDiskReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.attachDiskReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachedDisks(id int) ([]string, error) {
	fake.attachedDisksMutex.Lock()
	ret, specificReturn := fake.attachedDisksReturnsOnCall[len(fake.attachedDisksArgsForCall)]
	fake.attachedDisksArgsForCall = append(fake.attachedDisksArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("AttachedDisks", []interface{}{id})
	fake.attachedDisksMutex.Unlock()
	if fake.AttachedDisksStub != nil {
		return fake.AttachedDisksStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachedDisksReturns.result1, fake.attachedDisksReturns.result2
}

func (fake *FakeService) AttachedDisksCallCount() int {
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	return len(fake.attachedDisksArgsForCall)
}

func (fake *FakeService) AttachedDisksArgsForCall(i int) int {
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	return fake.attachedDisksArgsForCall[i].id
}

func (fake *FakeService) AttachedDisksReturns(result1 []string, result2 error) {
	fake.AttachedDisksStub = nil
	fake.attachedDisksReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachedDisksReturnsOnCall(i int, result1 []string, result2 error) {
	fake.AttachedDisksStub = nil
	if fake.attachedDisksReturnsOnCall == nil {
		fake.attachedDisksReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.attachedDisksReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachEphemeralDisk(id int, diskSize int) error {
	fake.attachEphemeralDiskMutex.Lock()
	ret, specificReturn := fake.attachEphemeralDiskReturnsOnCall[len(fake.attachEphemeralDiskArgsForCall)]
	fake.attachEphemeralDiskArgsForCall = append(fake.attachEphemeralDiskArgsForCall, struct {
		id       int
		diskSize int
	}{id, diskSize})
	fake.recordInvocation("AttachEphemeralDisk", []interface{}{id, diskSize})
	fake.attachEphemeralDiskMutex.Unlock()
	if fake.AttachEphemeralDiskStub != nil {
		return fake.AttachEphemeralDiskStub(id, diskSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachEphemeralDiskReturns.result1
}

func (fake *FakeService) AttachEphemeralDiskCallCount() int {
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	return len(fake.attachEphemeralDiskArgsForCall)
}

func (fake *FakeService) AttachEphemeralDiskArgsForCall(i int) (int, int) {
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	return fake.attachEphemeralDiskArgsForCall[i].id, fake.attachEphemeralDiskArgsForCall[i].diskSize
}

func (fake *FakeService) AttachEphemeralDiskReturns(result1 error) {
	fake.AttachEphemeralDiskStub = nil
	fake.attachEphemeralDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachEphemeralDiskReturnsOnCall(i int, result1 error) {
	fake.AttachEphemeralDiskStub = nil
	if fake.attachEphemeralDiskReturnsOnCall == nil {
		fake.attachEphemeralDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachEphemeralDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Create(virtualGuest *datatypes.Virtual_Guest, enableVps bool, stemcellID int, sshKeys []int, userData *registry.SoftlayerUserData) (int, error) {
	var sshKeysCopy []int
	if sshKeys != nil {
		sshKeysCopy = make([]int, len(sshKeys))
		copy(sshKeysCopy, sshKeys)
	}
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		virtualGuest *datatypes.Virtual_Guest
		enableVps    bool
		stemcellID   int
		sshKeys      []int
		userData     *registry.SoftlayerUserData
	}{virtualGuest, enableVps, stemcellID, sshKeysCopy, userData})
	fake.recordInvocation("Create", []interface{}{virtualGuest, enableVps, stemcellID, sshKeysCopy, userData})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(virtualGuest, enableVps, stemcellID, sshKeys, userData)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeService) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeService) CreateArgsForCall(i int) (*datatypes.Virtual_Guest, bool, int, []int, *registry.SoftlayerUserData) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].virtualGuest, fake.createArgsForCall[i].enableVps, fake.createArgsForCall[i].stemcellID, fake.createArgsForCall[i].sshKeys, fake.createArgsForCall[i].userData
}

func (fake *FakeService) CreateReturns(result1 int, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) UpgradeInstance(id int, cpu int, memory int, network int, privateCPU bool, dedicatedHost bool) error {
	fake.upgradeInstanceMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceReturnsOnCall[len(fake.upgradeInstanceArgsForCall)]
	fake.upgradeInstanceArgsForCall = append(fake.upgradeInstanceArgsForCall, struct {
		id            int
		cpu           int
		memory        int
		network       int
		privateCPU    bool
		dedicatedHost bool
	}{id, cpu, memory, network, privateCPU, dedicatedHost})
	fake.recordInvocation("UpgradeInstance", []interface{}{id, cpu, memory, network, privateCPU, dedicatedHost})
	fake.upgradeInstanceMutex.Unlock()
	if fake.UpgradeInstanceStub != nil {
		return fake.UpgradeInstanceStub(id, cpu, memory, network, privateCPU, dedicatedHost)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeInstanceReturns.result1
}

func (fake *FakeService) UpgradeInstanceCallCount() int {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return len(fake.upgradeInstanceArgsForCall)
}

func (fake *FakeService) UpgradeInstanceArgsForCall(i int) (int, int, int, int, bool, bool) {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return fake.upgradeInstanceArgsForCall[i].id, fake.upgradeInstanceArgsForCall[i].cpu, fake.upgradeInstanceArgsForCall[i].memory, fake.upgradeInstanceArgsForCall[i].network, fake.upgradeInstanceArgsForCall[i].privateCPU, fake.upgradeInstanceArgsForCall[i].dedicatedHost
}

func (fake *FakeService) UpgradeInstanceReturns(result1 error) {
	fake.UpgradeInstanceStub = nil
	fake.upgradeInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) UpgradeInstanceReturnsOnCall(i int, result1 error) {
	fake.UpgradeInstanceStub = nil
	if fake.upgradeInstanceReturnsOnCall == nil {
		fake.upgradeInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) ConfigureNetworks(id int, networks instance.Networks) (instance.Networks, error) {
	fake.configureNetworksMutex.Lock()
	ret, specificReturn := fake.configureNetworksReturnsOnCall[len(fake.configureNetworksArgsForCall)]
	fake.configureNetworksArgsForCall = append(fake.configureNetworksArgsForCall, struct {
		id       int
		networks instance.Networks
	}{id, networks})
	fake.recordInvocation("ConfigureNetworks", []interface{}{id, networks})
	fake.configureNetworksMutex.Unlock()
	if fake.ConfigureNetworksStub != nil {
		return fake.ConfigureNetworksStub(id, networks)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.configureNetworksReturns.result1, fake.configureNetworksReturns.result2
}

func (fake *FakeService) ConfigureNetworksCallCount() int {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return len(fake.configureNetworksArgsForCall)
}

func (fake *FakeService) ConfigureNetworksArgsForCall(i int) (int, instance.Networks) {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return fake.configureNetworksArgsForCall[i].id, fake.configureNetworksArgsForCall[i].networks
}

func (fake *FakeService) ConfigureNetworksReturns(result1 instance.Networks, result2 error) {
	fake.ConfigureNetworksStub = nil
	fake.configureNetworksReturns = struct {
		result1 instance.Networks
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ConfigureNetworksReturnsOnCall(i int, result1 instance.Networks, result2 error) {
	fake.ConfigureNetworksStub = nil
	if fake.configureNetworksReturnsOnCall == nil {
		fake.configureNetworksReturnsOnCall = make(map[int]struct {
			result1 instance.Networks
			result2 error
		})
	}
	fake.configureNetworksReturnsOnCall[i] = struct {
		result1 instance.Networks
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CleanUp(id int) error {
	fake.cleanUpMutex.Lock()
	ret, specificReturn := fake.cleanUpReturnsOnCall[len(fake.cleanUpArgsForCall)]
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("CleanUp", []interface{}{id})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		return fake.CleanUpStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanUpReturns.result1
}

func (fake *FakeService) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeService) CleanUpArgsForCall(i int) int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return fake.cleanUpArgsForCall[i].id
}

func (fake *FakeService) CleanUpReturns(result1 error) {
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CleanUpReturnsOnCall(i int, result1 error) {
	fake.CleanUpStub = nil
	if fake.cleanUpReturnsOnCall == nil {
		fake.cleanUpReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanUpReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateSshKey(label string, key string, fingerPrint string) (int, error) {
	fake.createSshKeyMutex.Lock()
	ret, specificReturn := fake.createSshKeyReturnsOnCall[len(fake.createSshKeyArgsForCall)]
	fake.createSshKeyArgsForCall = append(fake.createSshKeyArgsForCall, struct {
		label       string
		key         string
		fingerPrint string
	}{label, key, fingerPrint})
	fake.recordInvocation("CreateSshKey", []interface{}{label, key, fingerPrint})
	fake.createSshKeyMutex.Unlock()
	if fake.CreateSshKeyStub != nil {
		return fake.CreateSshKeyStub(label, key, fingerPrint)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createSshKeyReturns.result1, fake.createSshKeyReturns.result2
}

func (fake *FakeService) CreateSshKeyCallCount() int {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return len(fake.createSshKeyArgsForCall)
}

func (fake *FakeService) CreateSshKeyArgsForCall(i int) (string, string, string) {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return fake.createSshKeyArgsForCall[i].label, fake.createSshKeyArgsForCall[i].key, fake.createSshKeyArgsForCall[i].fingerPrint
}

func (fake *FakeService) CreateSshKeyReturns(result1 int, result2 error) {
	fake.CreateSshKeyStub = nil
	fake.createSshKeyReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateSshKeyReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreateSshKeyStub = nil
	if fake.createSshKeyReturnsOnCall == nil {
		fake.createSshKeyReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createSshKeyReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) Delete(id int, enableVps bool) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		id        int
		enableVps bool
	}{id, enableVps})
	fake.recordInvocation("Delete", []interface{}{id, enableVps})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(id, enableVps)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeService) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeService) DeleteArgsForCall(i int) (int, bool) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].id, fake.deleteArgsForCall[i].enableVps
}

func (fake *FakeService) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DetachDisk(id int, diskID int) error {
	fake.detachDiskMutex.Lock()
	ret, specificReturn := fake.detachDiskReturnsOnCall[len(fake.detachDiskArgsForCall)]
	fake.detachDiskArgsForCall = append(fake.detachDiskArgsForCall, struct {
		id     int
		diskID int
	}{id, diskID})
	fake.recordInvocation("DetachDisk", []interface{}{id, diskID})
	fake.detachDiskMutex.Unlock()
	if fake.DetachDiskStub != nil {
		return fake.DetachDiskStub(id, diskID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.detachDiskReturns.result1
}

func (fake *FakeService) DetachDiskCallCount() int {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return len(fake.detachDiskArgsForCall)
}

func (fake *FakeService) DetachDiskArgsForCall(i int) (int, int) {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return fake.detachDiskArgsForCall[i].id, fake.detachDiskArgsForCall[i].diskID
}

func (fake *FakeService) DetachDiskReturns(result1 error) {
	fake.DetachDiskStub = nil
	fake.detachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DetachDiskReturnsOnCall(i int, result1 error) {
	fake.DetachDiskStub = nil
	if fake.detachDiskReturnsOnCall == nil {
		fake.detachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DeleteSshKey(id int) error {
	fake.deleteSshKeyMutex.Lock()
	ret, specificReturn := fake.deleteSshKeyReturnsOnCall[len(fake.deleteSshKeyArgsForCall)]
	fake.deleteSshKeyArgsForCall = append(fake.deleteSshKeyArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("DeleteSshKey", []interface{}{id})
	fake.deleteSshKeyMutex.Unlock()
	if fake.DeleteSshKeyStub != nil {
		return fake.DeleteSshKeyStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSshKeyReturns.result1
}

func (fake *FakeService) DeleteSshKeyCallCount() int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return len(fake.deleteSshKeyArgsForCall)
}

func (fake *FakeService) DeleteSshKeyArgsForCall(i int) int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return fake.deleteSshKeyArgsForCall[i].id
}

func (fake *FakeService) DeleteSshKeyReturns(result1 error) {
	fake.DeleteSshKeyStub = nil
	fake.deleteSshKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DeleteSshKeyReturnsOnCall(i int, result1 error) {
	fake.DeleteSshKeyStub = nil
	if fake.deleteSshKeyReturnsOnCall == nil {
		fake.deleteSshKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSshKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Edit(id int, instance *datatypes.Virtual_Guest) error {
	fake.editMutex.Lock()
	ret, specificReturn := fake.editReturnsOnCall[len(fake.editArgsForCall)]
	fake.editArgsForCall = append(fake.editArgsForCall, struct {
		id       int
		instance *datatypes.Virtual_Guest
	}{id, instance})
	fake.recordInvocation("Edit", []interface{}{id, instance})
	fake.editMutex.Unlock()
	if fake.EditStub != nil {
		return fake.EditStub(id, instance)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.editReturns.result1
}

func (fake *FakeService) EditCallCount() int {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return len(fake.editArgsForCall)
}

func (fake *FakeService) EditArgsForCall(i int) (int, *datatypes.Virtual_Guest) {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return fake.editArgsForCall[i].id, fake.editArgsForCall[i].instance
}

func (fake *FakeService) EditReturns(result1 error) {
	fake.EditStub = nil
	fake.editReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) EditReturnsOnCall(i int, result1 error) {
	fake.EditStub = nil
	if fake.editReturnsOnCall == nil {
		fake.editReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.editReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Find(id int) (*datatypes.Virtual_Guest, error) {
	fake.findMutex.Lock()
	ret, specificReturn := fake.findReturnsOnCall[len(fake.findArgsForCall)]
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("Find", []interface{}{id})
	fake.findMutex.Unlock()
	if fake.FindStub != nil {
		return fake.FindStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReturns.result1, fake.findReturns.result2
}

func (fake *FakeService) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeService) FindArgsForCall(i int) int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return fake.findArgsForCall[i].id
}

func (fake *FakeService) FindReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindStub = nil
	if fake.findReturnsOnCall == nil {
		fake.findReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.findReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindByPrimaryBackendIp(ip string) (*datatypes.Virtual_Guest, error) {
	fake.findByPrimaryBackendIpMutex.Lock()
	ret, specificReturn := fake.findByPrimaryBackendIpReturnsOnCall[len(fake.findByPrimaryBackendIpArgsForCall)]
	fake.findByPrimaryBackendIpArgsForCall = append(fake.findByPrimaryBackendIpArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("FindByPrimaryBackendIp", []interface{}{ip})
	fake.findByPrimaryBackendIpMutex.Unlock()
	if fake.FindByPrimaryBackendIpStub != nil {
		return fake.FindByPrimaryBackendIpStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findByPrimaryBackendIpReturns.result1, fake.findByPrimaryBackendIpReturns.result2
}

func (fake *FakeService) FindByPrimaryBackendIpCallCount() int {
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	return len(fake.findByPrimaryBackendIpArgsForCall)
}

func (fake *FakeService) FindByPrimaryBackendIpArgsForCall(i int) string {
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	return fake.findByPrimaryBackendIpArgsForCall[i].ip
}

func (fake *FakeService) FindByPrimaryBackendIpReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindByPrimaryBackendIpStub = nil
	fake.findByPrimaryBackendIpReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindByPrimaryBackendIpReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindByPrimaryBackendIpStub = nil
	if fake.findByPrimaryBackendIpReturnsOnCall == nil {
		fake.findByPrimaryBackendIpReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.findByPrimaryBackendIpReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindByPrimaryIp(ip string) (*datatypes.Virtual_Guest, error) {
	fake.findByPrimaryIpMutex.Lock()
	ret, specificReturn := fake.findByPrimaryIpReturnsOnCall[len(fake.findByPrimaryIpArgsForCall)]
	fake.findByPrimaryIpArgsForCall = append(fake.findByPrimaryIpArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("FindByPrimaryIp", []interface{}{ip})
	fake.findByPrimaryIpMutex.Unlock()
	if fake.FindByPrimaryIpStub != nil {
		return fake.FindByPrimaryIpStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findByPrimaryIpReturns.result1, fake.findByPrimaryIpReturns.result2
}

func (fake *FakeService) FindByPrimaryIpCallCount() int {
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	return len(fake.findByPrimaryIpArgsForCall)
}

func (fake *FakeService) FindByPrimaryIpArgsForCall(i int) string {
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	return fake.findByPrimaryIpArgsForCall[i].ip
}

func (fake *FakeService) FindByPrimaryIpReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindByPrimaryIpStub = nil
	fake.findByPrimaryIpReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindByPrimaryIpReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.FindByPrimaryIpStub = nil
	if fake.findByPrimaryIpReturnsOnCall == nil {
		fake.findByPrimaryIpReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.findByPrimaryIpReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetVlan(id int, mask string) (*datatypes.Network_Vlan, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetVlan", []interface{}{id, mask})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVlanReturns.result1, fake.getVlanReturns.result2
}

func (fake *FakeService) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeService) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return fake.getVlanArgsForCall[i].id, fake.getVlanArgsForCall[i].mask
}

func (fake *FakeService) GetVlanReturns(result1 *datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 *datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetVlanReturnsOnCall(i int, result1 *datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Vlan
			result2 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetSubnet(id int, mask string) (*datatypes.Network_Subnet, error) {
	fake.getSubnetMutex.Lock()
	ret, specificReturn := fake.getSubnetReturnsOnCall[len(fake.getSubnetArgsForCall)]
	fake.getSubnetArgsForCall = append(fake.getSubnetArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetSubnet", []interface{}{id, mask})
	fake.getSubnetMutex.Unlock()
	if fake.GetSubnetStub != nil {
		return fake.GetSubnetStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSubnetReturns.result1, fake.getSubnetReturns.result2
}

func (fake *FakeService) GetSubnetCallCount() int {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return len(fake.getSubnetArgsForCall)
}

func (fake *FakeService) GetSubnetArgsForCall(i int) (int, string) {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return fake.getSubnetArgsForCall[i].id, fake.getSubnetArgsForCall[i].mask
}

func (fake *FakeService) GetSubnetReturns(result1 *datatypes.Network_Subnet, result2 error) {
	fake.GetSubnetStub = nil
	fake.getSubnetReturns = struct {
		result1 *datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetSubnetReturnsOnCall(i int, result1 *datatypes.Network_Subnet, result2 error) {
	fake.GetSubnetStub = nil
	if fake.getSubnetReturnsOnCall == nil {
		fake.getSubnetReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Subnet
			result2 error
		})
	}
	fake.getSubnetReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Subnet
		result2 error
	}{result1, result2}
}

func (fake *FakeService) Reboot(id int) error {
	fake.rebootMutex.Lock()
	ret, specificReturn := fake.rebootReturnsOnCall[len(fake.rebootArgsForCall)]
	fake.rebootArgsForCall = append(fake.rebootArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("Reboot", []interface{}{id})
	fake.rebootMutex.Unlock()
	if fake.RebootStub != nil {
		return fake.RebootStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootReturns.result1
}

func (fake *FakeService) RebootCallCount() int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return len(fake.rebootArgsForCall)
}

func (fake *FakeService) RebootArgsForCall(i int) int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return fake.rebootArgsForCall[i].id
}

func (fake *FakeService) RebootReturns(result1 error) {
	fake.RebootStub = nil
	fake.rebootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) RebootReturnsOnCall(i int, result1 error) {
	fake.RebootStub = nil
	if fake.rebootReturnsOnCall == nil {
		fake.rebootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) ReloadOS(id int, stemcellID int, sshKeyIds []int, hostname string, domain string, userData *registry.SoftlayerUserData) error {
	var sshKeyIdsCopy []int
	if sshKeyIds != nil {
		sshKeyIdsCopy = make([]int, len(sshKeyIds))
		copy(sshKeyIdsCopy, sshKeyIds)
	}
	fake.reloadOSMutex.Lock()
	ret, specificReturn := fake.reloadOSReturnsOnCall[len(fake.reloadOSArgsForCall)]
	fake.reloadOSArgsForCall = append(fake.reloadOSArgsForCall, struct {
		id         int
		stemcellID int
		sshKeyIds  []int
		hostname   string
		domain     string
		userData   *registry.SoftlayerUserData
	}{id, stemcellID, sshKeyIdsCopy, hostname, domain, userData})
	fake.recordInvocation("ReloadOS", []interface{}{id, stemcellID, sshKeyIdsCopy, hostname, domain, userData})
	fake.reloadOSMutex.Unlock()
	if fake.ReloadOSStub != nil {
		return fake.ReloadOSStub(id, stemcellID, sshKeyIds, hostname, domain, userData)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadOSReturns.result1
}

func (fake *FakeService) ReloadOSCallCount() int {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return len(fake.reloadOSArgsForCall)
}

func (fake *FakeService) ReloadOSArgsForCall(i int) (int, int, []int, string, string, *registry.SoftlayerUserData) {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return fake.reloadOSArgsForCall[i].id, fake.reloadOSArgsForCall[i].stemcellID, fake.reloadOSArgsForCall[i].sshKeyIds, fake.reloadOSArgsForCall[i].hostname, fake.reloadOSArgsForCall[i].domain, fake.reloadOSArgsForCall[i].userData
}

func (fake *FakeService) ReloadOSReturns(result1 error) {
	fake.ReloadOSStub = nil
	fake.reloadOSReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) ReloadOSReturnsOnCall(i int, result1 error) {
	fake.ReloadOSStub = nil
	if fake.reloadOSReturnsOnCall == nil {
		fake.reloadOSReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadOSReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) SetMetadata(id int, vmMetadata instance.Metadata) error {
	fake.setMetadataMutex.Lock()
	ret, specificReturn := fake.setMetadataReturnsOnCall[len(fake.setMetadataArgsForCall)]
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		id         int
		vmMetadata instance.Metadata
	}{id, vmMetadata})
	fake.recordInvocation("SetMetadata", []interface{}{id, vmMetadata})
	fake.setMetadataMutex.Unlock()
	if fake.SetMetadataStub != nil {
		return fake.SetMetadataStub(id, vmMetadata)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMetadataReturns.result1
}

func (fake *FakeService) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeService) SetMetadataArgsForCall(i int) (int, instance.Metadata) {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return fake.setMetadataArgsForCall[i].id, fake.setMetadataArgsForCall[i].vmMetadata
}

func (fake *FakeService) SetMetadataReturns(result1 error) {
	fake.SetMetadataStub = nil
	fake.setMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) SetMetadataReturnsOnCall(i int, result1 error) {
	fake.SetMetadataStub = nil
	if fake.setMetadataReturnsOnCall == nil {
		fake.setMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) UpdateInstanceUserData(id int, userData *string) error {
	fake.updateInstanceUserDataMutex.Lock()
	ret, specificReturn := fake.updateInstanceUserDataReturnsOnCall[len(fake.updateInstanceUserDataArgsForCall)]
	fake.updateInstanceUserDataArgsForCall = append(fake.updateInstanceUserDataArgsForCall, struct {
		id       int
		userData *string
	}{id, userData})
	fake.recordInvocation("UpdateInstanceUserData", []interface{}{id, userData})
	fake.updateInstanceUserDataMutex.Unlock()
	if fake.UpdateInstanceUserDataStub != nil {
		return fake.UpdateInstanceUserDataStub(id, userData)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateInstanceUserDataReturns.result1
}

func (fake *FakeService) UpdateInstanceUserDataCallCount() int {
	fake.updateInstanceUserDataMutex.RLock()
	defer fake.updateInstanceUserDataMutex.RUnlock()
	return len(fake.updateInstanceUserDataArgsForCall)
}

func (fake *FakeService) UpdateInstanceUserDataArgsForCall(i int) (int, *string) {
	fake.updateInstanceUserDataMutex.RLock()
	defer fake.updateInstanceUserDataMutex.RUnlock()
	return fake.updateInstanceUserDataArgsForCall[i].id, fake.updateInstanceUserDataArgsForCall[i].userData
}

func (fake *FakeService) UpdateInstanceUserDataReturns(result1 error) {
	fake.UpdateInstanceUserDataStub = nil
	fake.updateInstanceUserDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) UpdateInstanceUserDataReturnsOnCall(i int, result1 error) {
	fake.UpdateInstanceUserDataStub = nil
	if fake.updateInstanceUserDataReturnsOnCall == nil {
		fake.updateInstanceUserDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateInstanceUserDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	fake.updateInstanceUserDataMutex.RLock()
	defer fake.updateInstanceUserDataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ instance.Service = new(FakeService)
